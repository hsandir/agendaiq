# AgendaIQ Project Rules - Education Management System

## PROJECT OVERVIEW
AgendaIQ is a comprehensive meeting and agenda management system for educational institutions with hierarchical role-based access control.

## üéØ CURSOR TEMPLATE SYSTEM

### CRITICAL: Always Use Templates
When creating ANY new file, you MUST use the appropriate template from `templates/cursor-templates/`:

#### 1. Server Components (Dashboard/Settings Pages)
```typescript
// Use: templates/cursor-templates/server-page-template.tsx
// Replace: PAGE_NAME, PAGE_TITLE, PAGE_DESCRIPTION
// Modify: Auth preset as needed
```

#### 2. Client Components (Interactive Pages)
```typescript
// Use: templates/cursor-templates/client-page-template.tsx  
// Replace: PAGE_NAME, PAGE_TITLE, PAGE_DESCRIPTION
// Modify: Admin check as needed
```

#### 3. API Routes (All Endpoints)
```typescript
// Use: templates/cursor-templates/api-route-template.ts
// Replace: MODEL_NAME, REQUIRED_FIELD
// Modify: Auth requirements as needed
// Remove: Unused HTTP methods
```

### Template Usage Instructions
1. **COPY** the entire template content first
2. **REPLACE** placeholder values (PAGE_NAME, etc.)
3. **MODIFY** auth requirements for the specific use case
4. **ADD** your specific functionality
5. **NEVER** skip auth checks or use different patterns

## CORE ARCHITECTURE PRINCIPLES

### 1. AUTHENTICATION & AUTHORIZATION SYSTEM
**CRITICAL: Always use our standardized auth system:**

```typescript
// REQUIRED AUTH IMPORTS
import { requireAuth, getCurrentUser, AuthPresets } from '@/lib/auth/auth-utils';
import { checkAuthRequirements } from '@/lib/auth/auth-utils';
import { withAuth } from '@/lib/auth/api-auth';

// STANDARD AUTH PATTERNS FOR PAGES (See MASTER_RULES.md for current system)
const user = await requireAuth(AuthPresets.requireAuth);      // Basic auth
const user = await requireAuth(AuthPresets.requireStaff);    // Staff required
const user = await requireAuth(AuthPresets.requireDevAdmin);  // Dev admin only
const user = await requireAuth(AuthPresets.requireOpsAdmin);  // Ops admin only

// STANDARD AUTH PATTERNS FOR API ROUTES (Use Capabilities)
import { Capability } from '@/lib/auth/policy';
const authResult = await withAuth(request, { 
  requireCapability: Capability.USER_MANAGE  // Use specific capability
});
if (!authResult.success) {
  return NextResponse.json({ error: authResult.error }, { status: authResult.statusCode });
}
const user = authResult.user!;
```

### 2. USER ROLE HIERARCHY
```typescript
// ROLE HIERARCHY - NUMERIC ROLEKEY SYSTEM
// See MASTER_RULES.md for full details
import { RoleKey } from '@/lib/auth/policy';

// System Roles (fixed):
RoleKey.DEV_ADMIN  // System Developer (highest privilege)
RoleKey.OPS_ADMIN  // Operations Administrator

// Organizational Roles (numeric, meaning varies by org):
RoleKey.ROLE_1     // Priority 1 (e.g., CEO, Superintendent)
RoleKey.ROLE_2     // Priority 2 (e.g., COO, Deputy)
RoleKey.ROLE_3     // Priority 3 (e.g., Director, Principal)
RoleKey.ROLE_4     // Priority 4 (e.g., Vice Director)
RoleKey.ROLE_5     // Priority 5 (e.g., Manager, Department Head)
RoleKey.ROLE_6     // Priority 6
RoleKey.ROLE_7     // Priority 7
RoleKey.ROLE_8     // Priority 8
RoleKey.ROLE_9     // Priority 9
RoleKey.ROLE_10    // Priority 10

// USER DATA STRUCTURE
interface AuthenticatedUser {
  id: number;
  email: string;
  name: string | null;
  staff?: {
    id: number;
    role: {
      id: number;
      key: string;        // RoleKey enum value
      title: string;      // Display name (varies by org)
      priority: number;   // 1-10 (lower = higher authority)
      category: string | null;
      is_leadership: boolean;
    };
    department: {
      id: number;
      name: string;
      code: string;
    };
    school: {
      id: number;
      name: string;
      code: string | null;
    };
    district: {
      id: number;
      name: string;
      code: string | null;
    };
  } | null;
}
```

### 3. DATABASE SCHEMA RULES
```prisma
// REQUIRED RELATIONSHIPS
User -> Staff (1:many)
Staff -> Role (many:1)
Staff -> Department (many:1)  
Staff -> School (many:1)
Staff -> District (many:1)
```

### 4. FILE STRUCTURE STANDARDS

#### Page Components (Server Components)
```typescript
// /src/app/[route]/page.tsx
import { requireAuth, AuthPresets } from '@/lib/auth/auth-utils';

export default async function PageName() {
  const user = await requireAuth(AuthPresets.requireAuth);
  // Page logic here
}
```

#### API Routes
```typescript
// /src/app/api/[route]/route.ts
import { withAuth } from '@/lib/auth/api-auth';
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  const authResult = await withAuth(request, { 
    requireCapability: Capability.USER_MANAGE  // Use capabilities, not roles
  });
  if (!authResult.success) {
    return NextResponse.json({ error: authResult.error }, { status: authResult.statusCode });
  }
  
  const user = authResult.user!;
  // API logic here
}
```

#### Component Structure
```typescript
// Client components: 'use client' at top
// Server components: No 'use client' directive
// Always import auth utilities correctly
```

### 5. STYLING & UI STANDARDS

#### CSS Framework
- Use Tailwind CSS exclusively
- No custom CSS files per component
- Use centralized theme system from `/src/lib/theme/`

#### Component Patterns
```typescript
// Consistent button styling
className="bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700"

// Consistent card styling  
className="bg-white p-6 rounded-lg shadow-sm border"

// Consistent form styling
className="space-y-4"
```

### 6. ERROR HANDLING STANDARDS

#### API Error Responses
```typescript
return NextResponse.json({
  error: 'Descriptive error message',
  code: 'ERROR_CODE',
  timestamp: new Date().toISOString()
}, { status: 400 });
```

#### Page Error Handling
```typescript
try {
  // Operation
} catch (error) {
  console.error('Context:', error);
  redirect('/dashboard?error=operation_failed');
}
```

### 7. DATA FETCHING PATTERNS

#### Server Components
```typescript
// Direct database calls with Prisma
const data = await prisma.model.findMany({
  where: { /* conditions */ },
  include: { /* relations */ }
});
```

#### Client Components
```typescript
// Use fetch with proper error handling
const response = await fetch('/api/endpoint');
if (!response.ok) {
  throw new Error(`API error: ${response.status}`);
}
```

### 8. LANGUAGE & LOCALIZATION
- 
All code, user interface, documentation, 
          + comments, and error messages must be in **ENGLISH ONLY**.
       15 +  
       16 +  - **User Interface**: English (corrected from mixed policy)
       17 +  - **Code Comments**: English for all types
       18 +  - **Console Logs**: English 
       19 +  - **Documentation**: English
       20 +  - **Error Messages**: English for all users
       21 +  - **Commit Messages**: English with detailed descriptions (no 
          + emojis)
       22 +  - **Variable Names**: English
       23 +  - **Function Names**: English
       24 +  - **Database Schema**: English field names
       25 +  


### 9. SECURITY REQUIREMENTS

#### Authentication
- Every page must use requireAuth() or similar
- Every API route must use withAuth() middleware
- No direct session access, use auth utilities

#### Data Validation
```typescript
// Validate all inputs
if (!email || !password) {
  return { error: 'Required fields missing' };
}

// Sanitize user inputs
const cleanInput = input.trim().toLowerCase();
```

### 10. MEETING SYSTEM SPECIFIC RULES

#### Meeting Creation
```typescript
// Always associate with authenticated user
const meeting = await prisma.meeting.create({
  data: {
    organizer_id: user.staff!.id,
    // other fields
  }
});
```

#### Meeting Access Control
```typescript
// Check meeting access permissions using capabilities
import { can, Capability } from '@/lib/auth/policy';

const hasAccess = meeting.organizer_id === user.staff!.id || 
                 can(user, Capability.MEETING_MANAGE) ||
                 meetingAttendees.some(a => a.staff_id === user.staff!.id);
```

### 11. CODING STANDARDS

#### TypeScript
- Always use TypeScript
- Define proper interfaces for all data structures
- Use strict type checking
- No `any` types unless absolutely necessary

#### Functions
```typescript
// Prefer async/await over promises
async function processData() {
  const result = await operation();
  return result;
}

// Use descriptive function names
async function createMeetingWithAttendees() { }
async function validateUserPermissions() { }
```

#### Import Organization
```typescript
// 1. External libraries
import { NextRequest } from 'next/server';

// 2. Internal utilities
import { requireAuth } from '@/lib/auth/auth-utils';

// 3. Components
import { Button } from '@/components/ui/button';

// 4. Types
import type { AuthenticatedUser } from '@/lib/auth/auth-utils';
```

### 12. GIT & VERSION CONTROL

#### Commit Messages
- Use descriptive, detailed commit messages
- No emojis or icons in commit messages
- Include context and impact of changes
- Reference issue numbers when applicable

#### Branching
- Feature branches for all new development
- Regular merges to main branch
- Monday backups from main/release branches

### 13. TESTING REQUIREMENTS

#### API Testing
```bash
# Always test API endpoints
curl -X POST 'http://localhost:3000/api/endpoint' \
  -H 'Content-Type: application/json' \
  -d '{"test": "data"}'
```

#### Page Testing
- Test authentication flows
- Verify role-based access control
- Check error handling paths

### 14. PERFORMANCE STANDARDS

#### Database Queries
```typescript
// Always include necessary relations
const user = await prisma.user.findUnique({
  where: { id },
  include: {
    Staff: {
      include: {
        Role: true,
        Department: true,
        School: true,
        District: true
      }
    }
  }
});
```

#### Pagination
```typescript
// Implement pagination for large datasets
const meetings = await prisma.meeting.findMany({
  take: 20,
  skip: page * 20,
  orderBy: { start_time: 'desc' }
});
```

### 15. DEPLOYMENT & ENVIRONMENT

#### Port Configuration
- Always use port 3000
- Kill existing processes if port is occupied
- Never change port numbers

#### Environment Variables
```env
# Required environment variables
DATABASE_URL=
NEXTAUTH_SECRET=
GOOGLE_CLIENT_ID=
GOOGLE_CLIENT_SECRET=
```

## MANDATORY CHECKS BEFORE CODE COMPLETION

1. ‚úÖ Uses standardized auth system
2. ‚úÖ Proper TypeScript types
3. ‚úÖ Error handling implemented
4. ‚úÖ Consistent styling with Tailwind
5. ‚úÖ Database relationships respected
6. ‚úÖ Role-based access control applied
8. ‚úÖ No security vulnerabilities
9. ‚úÖ Performance considerations addressed
10. ‚úÖ Testing verifies functionality

## FORBIDDEN PATTERNS

‚ùå Direct session access (use auth utilities)
‚ùå Custom CSS files (use Tailwind)
‚ùå Hardcoded user data (always fetch from database)
‚ùå Using role titles instead of RoleKey enum (use role.key === RoleKey.XXX)
‚ùå Missing authentication checks
‚ùå Unhandled errors
‚ùå English text in user interfaces
‚ùå Emojis in commit messages
‚ùå Any type usage without justification
‚ùå Direct database calls without auth verification
‚ùå Port number changes

## EMERGENCY PROTOCOLS

If authentication system fails:
1. Check auth-utils.ts exports
2. Verify auth-options.ts session callback
3. Test API middleware functionality
4. Validate database connections
5. Review migration system status

Follow these rules religiously. Any deviation must be explicitly justified and documented.

## LOCAL VALIDATION AGENT FOR CURSOR

### Setup Instructions
1. Navigate to validation-server directory: `cd validation-server`
2. Install dependencies: `npm install`
3. Start server: `npm start` (runs on http://localhost:3456)
4. Keep server running while using Cursor

### How It Works
- **No API Quota Usage**: Runs locally on your machine
- **Same as Claude Code Agent**: Provides identical validation functionality
- **Real-time**: Instant validation without network delays
- **Extensible**: Add custom schemas as needed

### Usage in Cursor
When you need to validate data, instead of asking Cursor AI to write validation:

```typescript
// DON'T DO THIS (uses Cursor quota):
// "Write validation for email field"

// DO THIS (uses local server):
const response = await fetch('http://localhost:3456/validate', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    schema: 'email',
    data: userEmail
  })
});
```

### Benefits Over AI Validation
1. **Zero quota usage** - Unlimited validations
2. **Consistent rules** - Same validation logic everywhere
3. **Type-safe** - Zod schemas ensure type safety
4. **Faster** - No AI processing time
5. **Offline capable** - Works without internet

This local validation server provides the exact same functionality as a validation agent but runs entirely on your machine without using any API quotas.